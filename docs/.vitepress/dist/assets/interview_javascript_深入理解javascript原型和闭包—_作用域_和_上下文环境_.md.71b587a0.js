import{_ as a,c as p,o as r,a as _}from"./app.16764a97.js";const t="/assets/scope1.1fa3f04e.png",s="/assets/scope2.fc7ff310.png",e="/assets/scope3.87269bcd.png",i="/assets/scope4.b3b46013.png",c="/assets/scope6.9d3431c6.png",w=JSON.parse('{"title":"深入理解javascript原型和闭包—[作用域]和[上下文环境]","description":"","frontmatter":{},"headers":[],"relativePath":"interview/javascript/深入理解javascript原型和闭包—[作用域]和[上下文环境].md"}'),o={name:"interview/javascript/深入理解javascript原型和闭包—[作用域]和[上下文环境].md"},n=_('<h1 id="深入理解javascript原型和闭包—-作用域-和-上下文环境" tabindex="-1">深入理解javascript原型和闭包—[作用域]和[上下文环境] <a class="header-anchor" href="#深入理解javascript原型和闭包—-作用域-和-上下文环境" aria-hidden="true">#</a></h1><p>本文把作用域和上下文环境结合起来说一下，会理解的更深 一些。</p><p>如上图，我们在上文中已经介绍了，除了全局作用域之外，每个函数都会创建自己的作用域，<strong>作用域在函数定义时就已经确定了。而不是在函数调用时确定。</strong></p><p>下面我们将按照程序执行的顺序，一步一步把各个上下文环境加上， 另外，对上下文环境不了解的朋友，可以去看看之前的两篇文章:</p><p>[深入理解javascript原型和闭包之[执行上下文栈] ][13.html]</p><p>[深入理解javascript原型和闭包之[简介--作用域] ][14.html]</p><p>第一步，在加载程序时， 已经确定了全局上下文环境，并随着程序的执行而对变量进行赋值。</p><img src="'+t+'" width="560" height="500"><p>第二步，调用fn(10)，此时生成此次调用fn函数的上下文环境，压栈，并将此上下文环境设置为活动状态。</p><img src="'+s+'" width="560" height="500"><p>第三步，调用bar(100),生成此次调用的上下文环境，压栈，并设置为活动状态。</p><img src="'+e+'" width="560" height="500"><p>第四步，bar(100)调用完成。则bar(100)上下文环境被销毁。接着调用bar(200)，则又生成bar(200)的上下文环境，压栈，设置为活动状态。</p><img src="'+i+'" width="560" height="500"><p>第五步，bar(200)调用结束，其上下文环境被销毁，此时会回到fn(10)上下文环境，变为活动状态。</p><img src="'+s+'" width="560" height="500"><p>第六步，fn(10)执行完成之后，fn(10)上下文环境被销毁，全局上下文环境又回到活动状态。</p><img src="'+t+'" width="560" height="500"><p>结束了。像老太太的裹脚布--又臭又长！</p><p>最后我们可以把以上这几个图片连接起来看看。</p><img src="'+c+'" width="800" height="560"><p>连接起来看，还是挺有意思的。<strong>作用域只是一个&quot;地盘&quot;，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值。</strong> 同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，<strong>作用域中变量的值是在执行过程中产生的确定的。而作用域却是在函数创建时就确定了。</strong></p>',22),h=[n];function d(g,m,f,v,j,l){return r(),p("div",null,h)}const u=a(o,[["render",d]]);export{w as __pageData,u as default};

import{_ as s,c as a,o as n,a as l}from"./app.16764a97.js";const A=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"深入理解javascript原型和闭包—简述【执行上下文】下","slug":"深入理解javascript原型和闭包—简述【执行上下文】下","link":"#深入理解javascript原型和闭包—简述【执行上下文】下","children":[]}],"relativePath":"interview/javascript/深入理解javascript原型和闭包—简述【执行上下文】下.md"}'),p={name:"interview/javascript/深入理解javascript原型和闭包—简述【执行上下文】下.md"},t=l(`<h2 id="深入理解javascript原型和闭包—简述【执行上下文】下" tabindex="-1">深入理解javascript原型和闭包—简述【执行上下文】下 <a class="header-anchor" href="#深入理解javascript原型和闭包—简述【执行上下文】下" aria-hidden="true">#</a></h2><p>上一篇我们讲到在全局环境下的代码段中，执行上下文环境中有如下数据：</p><ul><li>变量、函数表达式--变量声明，默认赋值为undefined;</li><li>this -- 赋值；</li><li>函数声明 --赋值；</li></ul><p>如果在函数中，除了以上数据之外，还会有其他数据。先看以下代码：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">fn</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">x</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">arguments</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">x</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#82AAFF;">fn</span><span style="color:#BABED8;">(</span><span style="color:#F78C6C;">10</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// [10] 10</span></span>
<span class="line"></span></code></pre></div><p>以上代码展示了在函数体的语句执行之前，arguments变量和函数的参数都已经被赋值。从这里可以看出，**函数每被调用一次，都会产生一个新的执行上下文环境。**因为不同的调用可能就会有不同的参数。</p><p>另外一点不同在于，**函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域。**至于”自由变量“和”作用域“是后面要专门拿出来讲述的重点，这里就先点到为止。用一个例子说明一下：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#BABED8;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">fn</span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">a</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// a是自由变量</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#676E95;font-style:italic;">// 函数创建时，就确定了a要取值的作用域</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">bar</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">f</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">a</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">20</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">f</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 打印&quot;10&quot;,而不是&quot;20&quot;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#82AAFF;">bar</span><span style="color:#BABED8;">(fn)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>好了，总结完了函数的附加内容，</p><p>全局代码的上下文环境数据内容为：</p><table><thead><tr><th>普通变量（包括函数表达式），如： vara = 10;</th><th>声明（默认赋值为undefined）</th></tr></thead><tbody><tr><td>函数声明，如： function fn()</td><td>赋值</td></tr><tr><td>this</td><td>赋值</td></tr></tbody></table><p>如果代码段是函数体，那么在此基础上需要附加：</p><table><thead><tr><th>参数</th><th>赋值</th></tr></thead><tbody><tr><td>arguments</td><td>赋值</td></tr><tr><td>自由变量的取值作用域</td><td>赋值</td></tr></tbody></table><p>给执行上下文环境下一个通俗的定义-- <strong>在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。</strong></p><p>了解了执行上下文环境中的数据信息，你就不用再去死记硬背那些可恶的面试题了。理解了就不用背诵！</p><p>讲完了上下文环境，又来了新的问题--在执行js代码时，会有数不清的函数调用次数，会产生许多个上下文环境。这么多上下文环境该如何管理，以及如何销毁释放内存呢？下一节将通过&quot;执行上下文栈&quot;来解释这个问题。</p>`,16),o=[t];function e(c,r,i,y,F,D){return n(),a("div",null,o)}const _=s(p,[["render",e]]);export{A as __pageData,_ as default};

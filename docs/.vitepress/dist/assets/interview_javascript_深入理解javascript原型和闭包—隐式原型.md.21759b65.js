import{_ as s,c as o,o as p,a as n}from"./app.16764a97.js";const a="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN8AAAAnCAIAAAF3XTqZAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPuSURBVGhD7ZWBdqwgDET7/z/dRoemYxIQFF203NO3HYYQQuBtv74vICX9+k3+9Qs0TIH1LnGoT3E2qa6vTBRUsPxbUQHYNxrAEaBhCsnqzkya6NjfSyq9gllob6oK9U+txqknt5b949lv5kWFav9rLug6lj1kI92LNZA6UIoWpA5gfR283/LDoAKtI1fQ3YWWuaeaAh/evp7+hV7U+yUpUuc+AWugMTqlDg8NbOZ0iE0qAmAo6NALaC+gVTAwhTReMUNgY9Lv4XlMoU+hT0PDN9bE+QyD8HcMnIjPVT4jt8C3o7VBL2yowIcSjaEKj3ZBBMBQYF1DGN+aZASeV/Hg9Gno8jj3XlNNDPBhNc6dFHbfTEichrIAPFQNIRjNQ8XEJLWNN74KwEPoXRAsQOunEUCHEAU4ZqPT70KEyw7H+Dr08UoYk4svx+RWeWryCzqszxxyanEv5Az1x8gFwxe8XuePgCSC0QY2j282CZkN7cnsZk86dNN/oYRfMTUcXjgIY1X/km7KKfRHh943bP6iZTQQR0lWRHl2fLLV67nKB+Tzn+/Fe7opBwnPUj7g7CYTV49Dyaf+hOjhRXRpRJckH6R/9b06+0T+6bEvYnazJ326WfNf+/B/f79w2G+S4cp6xHdursiNy0HQ/AmhWmCtmJgcGoN4AUOGzZwug0j9VNbJvzxsCqybKC2r2aDVZ1pjauJzYK3PkMt5bK/SGs7Yd1cQrjVmTQ01YK3PkMtZ3iu7Kv1e4SBo+VTBQ6CafaMhBPYF1oIZAjWXlcWAMghbcyzAFGp0EweXdWQ5X0v1YTzMHCmokbTYkaYjPt/NNzG72ZPZzcm4zNe5gf/SsJ58hIG6v/sUbnguJv/V203KPOl13sB8nUMRdJ9vpEZjqI6ZCtFb5+sXbYZJEaHZi/t3nJSJW48b8fciTjjlIwuY+9Zhzmd234oEeNJcBSa4ae2kO9nu+3tRR4SZbb1EvXW+/pqXcfVzqalhchsP6D4/kRtep27B2lOYmvRitngyLvN1TsZlvs5a5p/yMxzr3nAd7/UIOj6mylS7YRJQmeqttB5/uGb1ur/787zj5V19iqb8cSinCLUxzdAIgbUQxoBdxweEhGFq8mxOg6Y8ZpgUEZonWbeN9+Up4xuheEcoxLfSlKFUisH4uYp5KBqk8UrTUFjWb0kTRXyYcXi4JF1JY8KbxtFhzmdC8ySFfWtqKA+F3YAmmpbHoZwi1LkA4XAM2HV4rZliwik1zeyS6JdkEd5Uh6dM2G4q0WFMKyZPTjPq+4BwqhDfROvyU5u9A9OyXAcPXwwvPJykwBU5u7NbZBjwgINN/i3zdU5G5fv7B7/oaM/FMAAiAAAAAElFTkSuQmCC",t="/assets/181508340651970.f023a6c7.png",l="/assets/181509180812624.096b544f.png",e="/assets/181510403153733.3ebd6e30.png",c="/assets/181512068463597.5ef01456.png",r="/assets/181512489403338.02e211a1.png",j=JSON.parse('{"title":"深入理解javascript原型和闭包—隐式原型","description":"","frontmatter":{},"headers":[],"relativePath":"interview/javascript/深入理解javascript原型和闭包—隐式原型.md"}'),_={name:"interview/javascript/深入理解javascript原型和闭包—隐式原型.md"},A=n('<h1 id="深入理解javascript原型和闭包—隐式原型" tabindex="-1">深入理解javascript原型和闭包—隐式原型 <a class="header-anchor" href="#深入理解javascript原型和闭包—隐式原型" aria-hidden="true">#</a></h1><blockquote><p>每个函数function都有一个prototype，即原型。每个对象都有一个__proto__，可成为隐式原型。</p></blockquote><p>这个__proto__是一个隐藏的属性，javascript不希望开发者用到这个属性值，有的低版本浏览器甚至不支持这个属性值。所以一般编辑器中，都不会有__proto__的智能提示，但是你不用管它，直接写出来就是了。</p><p><img src="'+a+'" alt="16f879b5b51541a1"></p><p><img src="'+t+'" alt="16f879b5b51541a1"></p><p>上面截图看来，obj.__proto__和Object.prototype的属性一样！</p><p>obj这个对象本质上是被Object函数创建的，因此obj.__proto__和Object.prototype的属性一样。如下图所示：</p><p><img src="'+l+'" alt="16f879b5b51541a1"></p><p>即，<strong>每个对象都有一个__proto__属性，指向创建该对象的函数的prototype。</strong></p><p>但是<strong>Object.prototype确定是一个特例--它的__proto__指向的是null，切记切记！</strong></p><p><img src="'+e+`" alt="16f879b5b51541a1"></p><p>函数也是一种对象，函数也有__proto__属性</p><p>函数也是被创建出来的，谁创建了函数呢？答案是Function，注意这个大写的&quot;F&quot;。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">fn</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">x</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;font-style:italic;">y</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">x</span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">y</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#82AAFF;">fn</span><span style="color:#BABED8;">(</span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">20</span><span style="color:#BABED8;">))</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#BABED8;"> fn1  </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Function</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">x</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">y</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">return x+ y;</span><span style="color:#89DDFF;">&quot;</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span><span style="color:#82AAFF;">fn1</span><span style="color:#BABED8;">(</span><span style="color:#F78C6C;">5</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">6</span><span style="color:#BABED8;">))</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>以上代码中，第一种方式是比较传统的创建函数的方式，第二种是用new Function创建的。</p><p><strong>不推荐使用第二种方式创建函数，这里只是向大家演示，函数是被Function创建的。</strong></p><p>根据上面的一句话--对象的__proto__指向的是创建它的函数的prototype，就会出现:obj.__proto__和Object.prototype的属性一样。如下图所示：</p><p><img src="`+c+'" alt="16f879b5b51541a1"></p><p>上图中，很明显的标出了：自定义函数Foo.__proto__指向Function.prototype，Object.__proto__指向Function.prototype，唉，怎么还有一个.......Function.__proto__指向Function.prototype?这不成了循环引用了？</p><p>对！是一个环形结构。</p><p>Function也是一个函数，函数是一种对象，也有__proto__属性。既然是函数，那么它一定是被Function创建的。所以Function是被自身创建的。所以它的__proto__指向了自身的prototype。</p><p>最后一个问题，Function.prototype指向的对象，它的__proto__是不是也指向Object.prototype？</p><p>答案是肯定的，因为Function.prototype指向的也是一个普通的被Object创建的对象，所以也遵循基本的规则。</p><p><img src="'+r+'" alt="16f879b5b51541a1"></p><blockquote><p>下节重点讲解--instanceof。</p></blockquote>',25),y=[A];function F(i,D,B,b,u,E){return p(),o("div",null,y)}const f=s(_,[["render",F]]);export{j as __pageData,f as default};

import{_ as s,c as n,o as a,a as o}from"./app.16764a97.js";const e="/assets/181635468939277.d8e94cab.png",t="/assets/181637013624694.968aea37.png",d=JSON.parse('{"title":"深入理解javascript原型和闭包—instanceof","description":"","frontmatter":{},"headers":[{"level":2,"title":"instanceof 可以清楚判断出引用类型的类型","slug":"instanceof-可以清楚判断出引用类型的类型","link":"#instanceof-可以清楚判断出引用类型的类型","children":[]},{"level":2,"title":"instanceof 判断规则","slug":"instanceof-判断规则","link":"#instanceof-判断规则","children":[]}],"relativePath":"interview/javascript/深入理解javascript原型和闭包—instanceof.md"}'),p={name:"interview/javascript/深入理解javascript原型和闭包—instanceof.md"},l=o(`<h1 id="深入理解javascript原型和闭包—instanceof" tabindex="-1">深入理解javascript原型和闭包—instanceof <a class="header-anchor" href="#深入理解javascript原型和闭包—instanceof" aria-hidden="true">#</a></h1><blockquote><p>对于值类型，你可以通过typeof判断，string/number/boolean都很清楚，但是typeof在判断引用类型的时候，返回值只有object/function，你不知道它到底是一个object对象，还是数组，还是new Number等等。</p></blockquote><h2 id="instanceof-可以清楚判断出引用类型的类型" tabindex="-1">instanceof 可以清楚判断出引用类型的类型 <a class="header-anchor" href="#instanceof-可以清楚判断出引用类型的类型" aria-hidden="true">#</a></h2><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Foo</span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#BABED8;"> f1 </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Foo</span><span style="color:#BABED8;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(f1 </span><span style="color:#89DDFF;">instanceof</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Foo</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(f1 </span><span style="color:#89DDFF;">instanceof</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Object</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"></span></code></pre></div><p><img src="`+e+`" alt="16f879b5b51541a1"></p><p>上图中，f1这个对象是被Foo创建的，但是&quot;f1 instanceof Object&quot;为什么是true呢？</p><h2 id="instanceof-判断规则" tabindex="-1">instanceof 判断规则 <a class="header-anchor" href="#instanceof-判断规则" aria-hidden="true">#</a></h2><p>​ Instanceof 运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。</p><p>​ Instanceof 的判断规则是：<strong>沿着A的proto这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。</strong></p><p>按照以上规则，很容易看出来，就是true。</p><p>通过以上规则，你可以理解很多比较怪异的现象，例如：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(Object </span><span style="color:#89DDFF;">instanceof</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Function</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(Function </span><span style="color:#89DDFF;">instanceof</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Object</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">//true</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(Function </span><span style="color:#89DDFF;">instanceof</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Function</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"></span></code></pre></div><p>这些看似很混乱的东西，答案却都是true，这是为何？见下图：</p><p><img src="`+t+'" alt="16f879b5b51541a1"></p><p>看这个图片，千万不要嫌烦，必须一条线一条线挨着分析。</p><p>问题来了，Instanceof这样设计，到底有什么用？到底Instanceof想表达什么呢？</p><p>重点就这样被这位老朋友给引出来了--继承--原型链。</p><p>即，instanceof表示的就是一种继承关系，或者原型链的结构。</p><blockquote><p>下节重点讲述继承和原型链</p></blockquote>',19),c=[l];function r(i,y,B,D,F,f){return a(),n("div",null,c)}const _=s(p,[["render",r]]);export{d as __pageData,_ as default};

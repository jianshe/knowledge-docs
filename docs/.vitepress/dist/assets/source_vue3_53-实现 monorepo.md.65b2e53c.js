import{_ as e,c as l,o as i,a as o}from"./app.16764a97.js";const _=JSON.parse('{"title":"53-实现 monorepo","description":"","frontmatter":{},"headers":[{"level":2,"title":"monorepo","slug":"monorepo","link":"#monorepo","children":[]},{"level":2,"title":"优点和缺点","slug":"优点和缺点","link":"#优点和缺点","children":[]},{"level":2,"title":"优点","slug":"优点","link":"#优点","children":[]},{"level":2,"title":"缺点","slug":"缺点","link":"#缺点","children":[]},{"level":2,"title":"主流的 monorepo 工具","slug":"主流的-monorepo-工具","link":"#主流的-monorepo-工具","children":[]},{"level":2,"title":"Vue3 是如何做的","slug":"vue3-是如何做的","link":"#vue3-是如何做的","children":[]},{"level":2,"title":"how","slug":"how","link":"#how","children":[{"level":3,"title":"1.使用 pnpm 的 monorepo。","slug":"_1-使用-pnpm-的-monorepo。","link":"#_1-使用-pnpm-的-monorepo。","children":[{"level":4,"title":"workplace","slug":"workplace","link":"#workplace","children":[]},{"level":4,"title":"包的依赖顺序","slug":"包的依赖顺序","link":"#包的依赖顺序","children":[]}]},{"level":3,"title":"2. 调整 build 逻辑。","slug":"_2-调整-build-逻辑。","link":"#_2-调整-build-逻辑。","children":[]},{"level":3,"title":"3. 使用 vitest 替换 jest。","slug":"_3-使用-vitest-替换-jest。","link":"#_3-使用-vitest-替换-jest。","children":[]}]}],"relativePath":"source/vue3/53-实现 monorepo.md"}'),r={name:"source/vue3/53-实现 monorepo.md"},a=o('<h1 id="_53-实现-monorepo" tabindex="-1">53-实现 monorepo <a class="header-anchor" href="#_53-实现-monorepo" aria-hidden="true">#</a></h1><h2 id="monorepo" tabindex="-1">monorepo <a class="header-anchor" href="#monorepo" aria-hidden="true">#</a></h2><ol><li>monorepo 是一种组织代码的方式，单个仓库，把相关的项目都放到一个仓库中。（一般情况下放到 packages 中，但不代表只能放到 packages 中）。</li></ol><h2 id="优点和缺点" tabindex="-1">优点和缺点 <a class="header-anchor" href="#优点和缺点" aria-hidden="true">#</a></h2><h2 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-hidden="true">#</a></h2><ol><li>共用基础设施，不需要我们重新配置了。</li><li>有依赖的项目之间调试开发非常方便。</li><li>第三方的库管理更简单了。</li></ol><h2 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-hidden="true">#</a></h2><ol><li>项目粒度的权限管理问题。</li><li>代码量比较庞大，对于新手不太友好。</li></ol><h2 id="主流的-monorepo-工具" tabindex="-1">主流的 monorepo 工具 <a class="header-anchor" href="#主流的-monorepo-工具" aria-hidden="true">#</a></h2><ol><li>npm</li><li>yarn</li><li>pnpm</li><li>larna</li><li>turborepo -&gt; 为了解决让我们更快的编辑和 build 命令。</li><li>nx -&gt; 为了解决让我们更快的编辑和 build 命令。</li><li>RushJS -&gt; 为了解决让我们更快的编辑和 build 命令。</li></ol><blockquote><p>解决执行管理，项目的 command。</p></blockquote><h2 id="vue3-是如何做的" tabindex="-1">Vue3 是如何做的 <a class="header-anchor" href="#vue3-是如何做的" aria-hidden="true">#</a></h2><ol><li>从之前的 yarn 升级了 pnpm。 -&gt; 利用软链接的方式节约磁盘空间，并提升安装速度。创建非扁平化的 node_modules 文件夹。</li><li>Build 命令 -&gt; Script/build.js</li><li>test 命令 -&gt; vitest</li></ol><h2 id="how" tabindex="-1">how <a class="header-anchor" href="#how" aria-hidden="true">#</a></h2><h3 id="_1-使用-pnpm-的-monorepo。" tabindex="-1">1.使用 pnpm 的 monorepo。 <a class="header-anchor" href="#_1-使用-pnpm-的-monorepo。" aria-hidden="true">#</a></h3><h4 id="workplace" tabindex="-1">workplace <a class="header-anchor" href="#workplace" aria-hidden="true">#</a></h4><blockquote><p>workplace 理解 workplace 的概念，一个 workspace 的根目录下必须有 pnpm-workspace.yaml 文件，也可能会有.npmrc 文件。<br> workplace 命令 Pnpm | xxx -W -&gt; 安装到 root 目录下;Pnpm | xxx -F xxx -&gt; 安装到指定项目下。<br> pnpm-workspace.yaml 指定一下路径。</p></blockquote><h4 id="包的依赖顺序" tabindex="-1">包的依赖顺序 <a class="header-anchor" href="#包的依赖顺序" aria-hidden="true">#</a></h4><ol><li>reactivity -&gt; shared</li><li>runtime-coure 依赖 reactivity 和 shared。</li><li>runtime-dom 依赖 runtime-core。</li><li>compiler-core 依赖 shard。</li></ol><h3 id="_2-调整-build-逻辑。" tabindex="-1">2. 调整 build 逻辑。 <a class="header-anchor" href="#_2-调整-build-逻辑。" aria-hidden="true">#</a></h3><h3 id="_3-使用-vitest-替换-jest。" tabindex="-1">3. 使用 vitest 替换 jest。 <a class="header-anchor" href="#_3-使用-vitest-替换-jest。" aria-hidden="true">#</a></h3>',21),n=[a];function t(d,h,c,s,p,u){return i(),l("div",null,n)}const k=e(r,[["render",t]]);export{_ as __pageData,k as default};
